;;; This file was automatically generated by SWIG (http://www.swig.org).
;;; Version 3.0.5
;;;
;;; Do not make changes to this file unless you know what you are doing--modify
;;; the SWIG interface file instead.

;;; Lisp parse tree produced by SWIG
(top :outfile "foo.lisp" :name "foomod" :module #1=(module :name "foomod")
   :inputfile "foo.i" :classes #2=(("std::initializer_list" . #3=(template :templatetype "class" :sym-typename "1" :name "initializer_list" :sym-symtab #4=(symboltable :name "std" :csymtab #5=(("initializer_list<(T)>" . #3#)
            ("initializer_list" . #3#))
           :symtab #6=(("initializer_list" . #3#))
          :children ((symboltable :name "initializer_list" :csymtab #7=(("T" . #8=(templateparm :name "T")))
               :symtab #9=())))
         :symtab #10=(symboltable :name "initializer_list" :csymtab #7# :symtab #9#)
         :allows-typedef t :kind "class" :sym-name "initializer_list" :sym-overname "__SWIG_0" :templateparms #11=(parm :name "T" :type "typename T")
        :children ((access :kind "public")))))
   :infile "foo.i" :outfile-h "foo_wrap.h"
  :children ((include :name "/Users/s3j/_local/swig-debug/share/swig/3.0.5/swig.swg"
      :children ((include :name "/Users/s3j/_local/swig-debug/share/swig/3.0.5/swigwarnings.swg"
          :children ((include :name "/Users/s3j/_local/swig-debug/share/swig/3.0.5/swigwarn.swg")))
        (namespace :sym-name "std" :name "std" :typescope #12=(:name "std" :typetab #13=(("initializer_list" . "initializer_list"))
             :parent #14=(("name" . "")
              ("typetab" . #15=()))
             :qname "std" :symtab #4#)
           :symtab #4# :sym-symtab #16=(symboltable :csymtab #17=(("set_something" . #18=(cdecl :name "set_something" :sym-symtab #16# :view "globalfunctionHandler" :kind "function" :sym-name "set_something" :wrap-parms #19=((:name "x" :type "int" :lname "arg1")
                    (:name "y" :type "double" :lname "arg2"))
                   :decl "f(int,double)." :parms #19# :wrap-action "set_something(arg1,arg2);" :type "void" :sym-overname "__SWIG_0"))
              ("get_something" . #20=(cdecl :name "get_something" :sym-symtab #16# :view "globalfunctionHandler" :kind "function" :sym-name "get_something" :wrap-parms #21=((:name "x" :type "int" :lname "arg1"))
                   :decl "f(int)." :parms #21# :wrap-action "result = (double)get_something(arg1);" :type "double" :sym-overname "__SWIG_0"))
              ("std" . #22=(namespace :sym-name "std" :name "std" :typescope #12# :symtab #4# :sym-symtab #16# :sym-overname "__SWIG_0"
                  :children ((template :templatetype "class" :sym-typename "1" :name "initializer_list" :sym-symtab #4# :symtab #10# :allows-typedef t :kind "class" :sym-name "initializer_list" :sym-overname "__SWIG_0" :templateparms #11#
                      :children ((access :kind "public")))
                    (typemap :kwargs #23=((:name "numinputs" :value "1")
                        (:name "warning" :value "476:Initialization using std::initializer_list."))
                       :code "" :method "in"
                      :children ((typemapitem :pattern #24=((:type "std::initializer_list<(T)>")))))
                    (typemap :kwargs #25=((:name "precedence" :value "0"))
                       :code "" :method "typecheck"
                      :children ((typemapitem :pattern #26=((:type "std::initializer_list<(T)>")))))))))
             :symtab #27=(("set_something" . #18#)
              ("get_something" . #20#)
              ("std" . #22#))
            :children ((symboltable :name "std" :csymtab #5# :symtab #6#
                :children ((symboltable :name "initializer_list" :csymtab #7# :symtab #9#)))))
           :sym-overname "__SWIG_0"
          :children ((template :templatetype "class" :sym-typename "1" :name "initializer_list" :sym-symtab #4# :symtab #10# :allows-typedef t :kind "class" :sym-name "initializer_list" :sym-overname "__SWIG_0" :templateparms #11#
              :children ((access :kind "public")))
            (typemap :kwargs #23# :code "" :method "in"
              :children ((typemapitem :pattern #24#)))
            (typemap :kwargs #25# :code "" :method "typecheck"
              :children ((typemapitem :pattern #26#)))))
        (typemap :code "delete [] $1;" :method "newfree"
          :children ((typemapitem :pattern #28=((:type "p.char")))))
        (typemap :code "{
  delete [] $1;
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}" :method "memberin"
          :children ((typemapitem :pattern #29=((:type "p.char")))))
        (typemap :kwargs #30=((:name "warning" :value "451:Setting a const char * variable may leak memory."))
           :code "{
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}" :method "memberin"
          :children ((typemapitem :pattern #31=((:type "p.q(const).char")))))
        (typemap :code "{
  delete [] $1;
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}" :method "globalin"
          :children ((typemapitem :pattern #32=((:type "p.char")))))
        (typemap :kwargs #33=((:name "warning" :value "451:Setting a const char * variable may leak memory."))
           :code "{
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}" :method "globalin"
          :children ((typemapitem :pattern #34=((:type "p.q(const).char")))))
        (typemap :code "{
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}" :method "memberin"
          :children ((typemapitem :pattern #35=((:type "a(ANY).char")))))
        (typemap :code "{
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}" :method "globalin"
          :children ((typemapitem :pattern #36=((:type "a(ANY).char")))))
        (typemap :code "{
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}" :method "memberin"
          :children ((typemapitem :pattern #37=((:type "a().char")))))
        (typemap :code "{
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}" :method "globalin"
          :children ((typemapitem :pattern #38=((:type "a().char")))))
        (typemap :code "{
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}" :method "memberin"
          :children ((typemapitem :pattern #39=((:type "a(ANY).SWIGTYPE")))))
        (typemap :code "{
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}" :method "globalin"
          :children ((typemapitem :pattern #40=((:type "a(ANY).SWIGTYPE")))))
        (typemap :code "{
  $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
  $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
  size_t ii = 0;
  for (; ii < $1_dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
  }
}" :method "memberin"
          :children ((typemapitem :pattern #41=((:type "a(ANY).a(ANY).SWIGTYPE")))))
        (typemap :code "{
  $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
  $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
  size_t ii = 0;
  for (; ii < $1_dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
  }
}" :method "globalin"
          :children ((typemapitem :pattern #42=((:type "a(ANY).a(ANY).SWIGTYPE")))))
        (insert :code "
#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};" :section "runtime")
        (insert :code "
template <typename T> T SwigValueInit() {
  return T();
}
#endif
" :section "runtime")
        (insert :code "/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility(\"default\")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

" :section "runtime")))
    (include :name "foo.i" :module "foomod" :options #43=(("maininput" . "foo.i"))
      :children ((insert :code "
#include \"foo.i\"
")
        (module :name "foomod")
        (include :name "foo.hh"
          :children ((cdecl :name "set_something" :sym-symtab #16# :view "globalfunctionHandler" :kind "function" :sym-name "set_something" :wrap-parms #19# :decl "f(int,double)." :parms #19# :wrap-action "set_something(arg1,arg2);" :type "void" :sym-overname "__SWIG_0")
            (cdecl :name "get_something" :sym-symtab #16# :view "globalfunctionHandler" :kind "function" :sym-name "get_something" :wrap-parms #21# :decl "f(int)." :parms #21# :wrap-action "result = (double)get_something(arg1);" :type "double" :sym-overname "__SWIG_0")))))))
