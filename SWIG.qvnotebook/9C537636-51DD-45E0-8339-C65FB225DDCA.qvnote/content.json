{
  "title": "Refactor of Fortran proxy code construction",
  "cells": [
    {
      "type": "markdown",
      "data": "- Make it look much closer to the C/C++ wrapper function code\n\n# FUNCTION PSEUDOCODE\n```\n  function swigc_$symname(farg1, farg2) &\n     bind(C, name=\"swigc_$symname\") &\n     result(fresult)\n   use, intrinsic :: ISO_C_BINDING\n   /imtype:out/ :: fresult\n   /imtype:bind/ :: farg1\n   /imtype:bind/ :: farg2\n  end function\n  \n  function swigf_$symname(arg1, arg2) &\n     result(swigf_result)\n   use, intrinsic :: ISO_C_BINDING\n   ! Dummy variables (parameters)\n   /ftype:out/ :: swigf_result\n   /ftype/ :: arg1\n   /ftype/ :: arg2\n   ! Local variables\n   /imtype/ :: farg1\n   /imtype/ :: farg2\n   /imtype:out/ :: fresult\n   ! Input typemaps\n   /fin/ (farg1 = arg1)\n   /fin/ (farg2 = arg2)\n   ! Function call\n   fresult = swigc_$symname(farg1, farg2)\n   ! Output typemap\n   /fout/ (swigf_result = fresult)\n  end function\n```\n\n# SUBROUTINE PSEUDOCODE\n```\n  subroutine swigc_$symname(farg1, farg2) &\n     bind(C, name=\"swigc_$symname\")\n   use, intrinsic :: ISO_C_BINDING\n   /imtype:bind/ :: farg1\n   /imtype:bind/ :: farg2\n  end subroutine\n\n  subroutine swigf_$symname(arg1, arg2)\n   use, intrinsic :: ISO_C_BINDING\n   ! Dummy variables (parameters)\n   /ftype/ :: arg1\n   /ftype/ :: arg2\n   ! Local variables\n   /imtype/ :: farg1\n   /imtype/ :: farg2\n   /imtype:out/ :: fresult\n   ! Input typemaps\n   /fin/ (farg1 = arg1)\n   /fin/ (farg2 = arg2)\n   ! Function call\n   call $symname(farg1, farg2)\n   /fout???/\n  end function\n```\n\n# CONSTRUCTOR PSEUDOCODE\n\n- `imtype` of the class should be `type(C_PTR)`\n- `ftype` of the class should be `type($fclassname)`\n- `$symname` will look like `new_$classname`\n- `swigf_$symname` will be mapped to `create`\n- Because of `intent` we need to allow the temporary `imtype` in the `swigf_` proxy functions to have a different declaration than the dummy variables in the `swigc_` function.\n\n```\n  function swigc_$symname(farg1) &\n     bind(C, name=\"swigc_$symname\") &\n     result(fresult)\n   use, intrinsic :: ISO_C_BINDING\n   /imtype:out/ :: fresult\n   /imtype:in/ :: farg1\n  end function\n  \n  subroutine swigf_$symname(arg1, arg2)\n   use, intrinsic :: ISO_C_BINDING\n   ! Dummy variables (parameters)\n   /ftype/ :: arg1\n   /ftype/ :: arg2\n   ! Local variables\n   /imtype/ :: farg1\n   /imtype/ :: farg2\n   /imtype:out/ :: fresult\n   ! Input typemaps\n   /fin/ (farg1 = arg1)\n   /fin/ (farg2 = arg2)\n   ! Function call\n   fresult = $symname(farg1, farg2)\n   ! Output typemap\n   /fout/ (self%swigptr = fresult)\n  end function\n```"
    },
    {
      "type": "markdown",
      "data": "# Type map variables\n\n`$symname`: Name of function/method being wrapped\n\n`in`: `$1 = fortran_to_c($input);`\n - `$input`  : Fortran object to be converted to C (i.e. `farg1`)\n - `$1`      : Destination C object (i.e. `arg1`)\n\n`out`: `$result = c_to_fortran($1);`\n - `$result` : Fortran object to be returned (i.e. `fresult`)\n - `$1`      : Source C object (i.e. `result`)\n\n`fin`: `$1 = fortran_to_proxy($input);`\n - `$input`  : Fortran object to be converted to intermediate code (i.e. `foo`)\n - `$1`      : Destination intermediate object (i.e. `farg1`)\n\n`fout`: `$result = proxy_to_fortran($1);`\n - `$result` : Fortran object to be returned (i.e. `swigf_result`)\n - `$1`      : Intermediate object (i.e. `fresult`)"
    },
    {
      "type": "markdown",
      "data": "# Refactor cleanup\n\nMost of the implementation is completed; some details remain.\n- Restore error checking code for calling `release` (return early if `self%own` is false)\n- In the `fin` typemaps, what should be `farg1` shows up as `arg1`\n- Simplify the `get_typemap` code\n- Improve printing of fortran subroutines to output (Wrapper_print)\n\nWeird typemap error probably related to the node argument of get_typemap (yep):\n```\n+++ parm - 0x10ef5bc20 ----------------------------------------\n| tmap:typecheck - \"\"\n| tmap:typecheck:match_type - \"int\"\n| tmap:in:match_type - \"int\"\n| tmap:ctype:match_type - \"int\"\n| tmap:imtype:match_type - \"int\"\n| tmap:ftype:match_type - \"int\"\n| tmap:imtype  - \"\"\n| name         - \"count\"\n| fname        - \"count\"\n| emit:input   - \"farg2\"\n| tmap:typecheck:precedence - \"45\"\n| tmap:imtype:in - \"integer(C_INT), intent(in)\"\n| tmap:ftype   - \"\"\n| tmap:in:numinputs - \"1\"\n| imname       - \"farg2\"\n| tmap:ctype   - \"const int*\"\n| tmap:in      - \"arg2 = *farg2;\"\n| type         - \"void\"\n| lname        - \"arg2\"\n| tmap:ctype:out - \"int\"\n| tmap:ftype:out - \"integer(C_INT)\"\n|\n/Users/s3j/_code/swig/Examples/fortran/barefunctions/bare.hh:26: Warning 460: No 'fin' typemap defined for void\n```"
    },
    {
      "type": "markdown",
      "data": "# Memory management in SWIG\n- Delete when you call \"new\"\n- Calling `SetAttr` increments the reference counter (should delete after using)\n- Calling `GetAttr` returns a reference, not a copy (don't delete)"
    },
    {
      "type": "markdown",
      "data": "# Overriding typemaps\n\nIt would be nice to automatically replace `fout` with `fcreate` and `frelease` where appropriate. But there's no way to specialize typemaps based on function names.\n\nThe `%feature` directive allows specific function names to be modified, but doesn't support regex\n\nMove constructor/destructor special case code to C++\n\nNew typemap: `imimport` allows importing typenames from module namespace, needed if fortran classes "
    }
  ]
}