{
  "title": "SWIG language features",
  "cells": [
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "# Overview \n\nThis chapter describes how to create interfaces to C and C++ data and functions in the target language of Fortran, a highly static, long-lived scientific programming language.\nThe primary motivation for adding the Fortran language to SWIG is to provide an automated means to adapt massively parallel scientific codes to modern solvers and GPU-accelerated kernels in the Trilinos numerical library package.\nBut in addition to this useful capability, SWIG-Fortran has potential to simplifty and accelerate numerous existing Fortran codes that do not require advanced numerical solvers.\nBy implementing automated coupling of C++ libraries to Fortran, we open up a new world of capability to Fortran users.\n\n## Fundamental concepts\n\nSWIG generates simple, flat C functions that provide access to underlying C/C++ data and functions that may operate on complex data types.\nFortran 2003 introduced features designed to finally provide standardized interactions between Fortran and ANSI C. \nIn particular, SWIGF generates wrapper functions that only take and return `ISO_C_BINDING`-compatible data types. These wrapper functions are responsible for converting any complex C datatypes to simpler ones compatible with Fortran.\n\nIn addition to generating a C++ file of wrapper code, SWIGF generates a Fortran module (one per `%module` SWIG directive).\nIn the private \"interface\" section of this module, SWIGF generates function interface declarations with the `BIND(C)` qualifier that exactly mirror the generated wrapper functions.\nIn SWIGF, all of the C-generated wrapper functions are prefixed with `swigc_`, so all of these interface functions likewise start with `swigc_`. \n\nFinally, SWIGF generates additional Fortran code that translates the simple function arguments and return values into their Fortran equivalents.\nFor simple data types this conversion is simply assignment, but other complex transformations can be performed that allow better native integration of C++ with Fortran.\nFor example, an `int*` return value can be transformed to a scalar Fortran `pointer` instead of being left as an opaque C pointer.\n\nSWIGF also generates \"proxy\" classes: thin wrappers to `swigc_` functions that allow C++ classes to be manipulated just like Fortran classes. \n\n# Feature descriptions\n\nWe fully leverage these capabilities in SWIG-Fortran and anticipate that future extensions of Fortran/C interoparability will increase the capability of the wrapper code as well as simplifying it. However, many features of C and C++ lie outside the `ISO_C_BINDING` compatibility module, and even some features that are interoperable (such as enumerations and structs) have capabilities that do not map between the two languages. With SWIG-Fortran we attempt to extend the Fortran/C++ mapping as much as possible, keeping in mind that Fortran and C are inherently different languages designed at different times with different purposes in mind.\n\n## Fundamental types\n\nSWIG maps a number of the fundamental C types to their ISO fortran equivalents via the `use, intrinsic :: ISO_C_BINDING` statement. The types mapped directly by SWIG are:\n\n```\nbool           logical(C_BOOL)    \nunsigned char  integer(C_INT8_T)  \nshort          integer(C_SHORT)   \nunsigned short integer(C_SHORT)   \nint            integer(C_INT)     \nunsigned int   integer(C_INT)     \nlong           integer(C_LONG)    \nunsigned long  integer(C_LONG)    \nlong long      integer(C_LONG_LONG)\nsize_t         integer(C_SIZE_T)  \nfloat          real(C_FLOAT)      \ndouble         real(C_DOUBLE)     \n```\n\nVoid pointers and handles are mapped to opaque `type(C_PTR)` types.\nNote that the above list does not include the standard C character `char` because of how Fortran treats arrays of character data (`CHARACTER, DIMENSION(:)`) from strings (`CHARACTER(LEN=*)`).\nPointers and references to the fundamental types are returned as scalar Fortran pointers: because the C return value does not contain any information about the shape of the data being pointed to, it is not possible to directly construct an array from a pointed-to value.\nHowever, advanced typemaps can be constructed (and indeed are provided by the SWIG fortran library) that *can* return that information or extend the Fortran interface to obtain the additional information needed to return an array pointer.\n\n## Functions\n\nFunctions in C/C++ are mapped with arguments directly corresponding between the two languages: one argument in the C code requires one argument in the Fortran proxy. (An exception is that C arguments can be ignored by swig using the `%typemap(in, numinputs=0)` directive in SWIG.)\n\n\n(array translation, C string translation)\n\n## Function pointers\n\nIt is possible to pass function pointers both from C to Fortran and from Fortran to C using SWIG.\n\nCalling C functions from Fortran as pointers can be done using [c_f_procpointer](https://software.intel.com/en-us/node/679091):\n```fortran\nSUBROUTINE CallIt (cp) BIND(C)\nUSE, INTRINSIC :: ISO_C_BINDING\nTYPE(C_FUNPTR), INTENT(IN) :: cp\nABSTRACT INTERFACE\n  SUBROUTINE Add_Int (i) BIND(C)\n  IMPORT\n  INTEGER(C_INT), INTENT(INOUT) :: i\n  END SUBROUTINE Add_Int\nEND INTERFACE\nPROCEDURE(Add_Int), POINTER :: fp\nINTEGER(C_INT) :: j\n\nCALL C_F_PROCPOINTER (cp, fp)\nj = 1\nCALL fp(j)\n...\n```\n\nSee the `funcptr` example in SWIG.\n\n## Classes\n\nNote that our SWIG implementation does not treat classes different from structs, nor does it detect which structs can be \"bound\" to Fortran equivalents.\nThe publicy accessible members of struct are wrapped as described below in \"member variables\".\n\n### Constructors and Destructors\n\nBecause Fortran is not a stack-based language like C (where variables enter and leave scope by being pushed onto and popped off the memory stack), it has little direct ability to \n\n## Variables\n\n### Member\n\n### Global\n\n\n## Enumerators\n\nFortran 2003 supports C-bound enumerations but ([apparently](https://www.ibm.com/support/knowledgecenter/SS2MB5_14.1.0/com.ibm.xlf141.bg.doc/language_ref/enum.html) [except for cray](http://docs.cray.com/books/S-3692-52/html-S-3692-52/z970507905n9123.html)?) does not allow them to be typed. To associate a C type with the fortran generated wrappers, SWIG generates an additional enumeration with the C class name and a placeholder value of `-1`. The enumeration generated from the C code\n```c\nenum MyEnum {\n    RED = 0,\n    GREEN,\n    BLUE,\n    BLACK = -1\n};\n```\nlooks like:\n```fortran\n enum, bind(c)\n  enumerator :: MyEnum = -1\n  enumerator :: RED = 0\n  enumerator :: GREEN = RED + 1\n  enumerator :: BLUE = GREEN + 1\n  enumerator :: BLACK = -1\n end enum\n ```\n \n These are then treated as standard C integers elsewhere in the code; on the Fortan side this is achieved with the dummy argument type `integer(kind(MyEnum))`.\n "
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "# Typemaps\n\nSWIG Fortran extends the typemap system of SWIG with additional typemaps. There are two new typemaps to declare the data types used by Fortran and C in the intermediate layer, and two typemaps for translating the intermediate layer types to the final Fortran types.\n\nTo pass Fortran-2003 compatible `BIND(\"C\")` types between C++ and Fortran, you must declare a compatible `ctype` and `ftype`. The `ctype` is the C datatype used by the wrapper and intermediate layer, and `ftype` is the equivalent Fortran datatype. These datatypes generally must be either fundamental types or structs of fundamental types. Note that fundamental types include the opaque pointer `void*` and its Fortran equivalent `type(C_PTR)` as well as function pointers and the opaque Fortran equivalent `type(C_FUNPTR)`.\n\nThe `fin` and `fout` typemaps are Fortran proxy wrapper code analogous to the `in` and `out` in the C wrapper code: they are used for translating native Fortran objects and types into types that can be transmitted through the C layer. For example, to pass a class by reference, the fortran class `class(SimpleClass) :: self` is converted to the corresponding C class via the stored C pointer using the `fin` typemap, which is expanded to:\n```fortran\nfarg1 = self%swigptr\n```\nThis argument is then passed into the C function call:\n```fortran\nfresult = swigc_make_class(farg1)\n```\nand the output is translated back via the `fout` typemap, which in this case expands to:\n```fortran\nswigf_result%swigptr = fresult\n```\n\nAdvanced SWIG users may know that \n```c++\n%typemap(in) int (double tempval) { /.../ }\n```\nis a way to declare a temporary variable `tempval` in the C wrapper code. The same feature is emulated in the special typemaps `findecl` and `foutdecl`, which are inserted into the variable declaration blocks when the corresponding types are used. If `findecl` allocates a temporary variable, the `ffrearg` typemap (analogous to the `freearg` typemap for C `in` arguments) can be used to deallocate it.\n\nIf types defined in the SWIG fortran module are to be used as part of the interface (as is the case with structs), it is necessary to \"import\" the type into the interface to use it. This is accomplished by the `imimport` macro. For example:\n```fortran\nmodule thinvec\n use, intrinsic :: ISO_C_BINDING\n implicit none\n\n type, public, bind(C) :: SwigfArrayWrapper\n   type(C_PTR), public :: data\n   integer(C_SIZE_T), public :: size\n end type\n interface\n subroutine swigc_foo(farg1) &\n   bind(C, name=\"swigc_foo\")\n   use, intrinsic :: ISO_C_BINDING\n   import :: SwigfArrayWrapper    ! Will not compile without this line\n   type(SwigfArrayWrapper) :: farg1\n end subroutine\n```\n"
    }
  ]
}