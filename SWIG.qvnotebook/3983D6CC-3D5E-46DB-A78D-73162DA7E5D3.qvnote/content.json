{
  "title": "SWIG language features",
  "cells": [
    {
      "type": "markdown",
      "data": "- [x] class constructor and destructor\n- [x] class methods with primitive arguments and return values\n- [x] methods/functions with class arguments\n- [x] template instantiation (SWIG should already handle this)\n- inheritance (only base class holds pointer)\n- [x] Ownership on fortran classes: return-by-value, return-by-new, const\n  reference\n- Move class return values to parameter values? (allow overloading for plist)\n- [x] multiple constructors\n- [x] `RCP/shared_ptr` wrapping (SWIG should already handle this)\n- [x] \"generic\" function overloading\n- [x] templated class method instantiation (needed for plist)\n- [x] namespaces\n- [x] string wrapping\n- [x] passing entire arrays of data in a single call\n- [x] Add 'intent' qualifiers to arguments?\n- [x] passing classes by value? (atypical fortran usage; RCP though)\n- [x] static methods/data\n- [x] Fortran callback functions\n- [x] enumerations?\n- [ ] global const data?\n- [ ] \"director\" capability to subclass a c++ class using a Fortran class\n- [ ] Multiple interacting modules\n- [ ] Iterators?\n- [x] Optional generation of `final` statement for auto-destruction\n- [ ] Optional typemap for checking validity of pointers (class must be\n  constructed)\n- [x] Find out about quirks of C++ static object initialization when executed\n  by a Fortran `main` function (no problems with gcc; see the SimpleClass\n  example)\n- [x] Exception handling?\n- [ ] Error checking (pointers being assigned)?\n- [ ] dynamic-cast type checking for inheritance upcasts?\n"
    },
    {
      "type": "markdown",
      "data": "Function pointers in fortran: calling C functions from fortran as pointers with [c_f_procpointer](https://software.intel.com/en-us/node/679091)\n```fortran\nSUBROUTINE CallIt (cp) BIND(C)\nUSE, INTRINSIC :: ISO_C_BINDING\nTYPE(C_FUNPTR), INTENT(IN) :: cp\nABSTRACT INTERFACE\n  SUBROUTINE Add_Int (i) BIND(C)\n  IMPORT\n  INTEGER(C_INT), INTENT(INOUT) :: i\n  END SUBROUTINE Add_Int\nEND INTERFACE\nPROCEDURE(Add_Int), POINTER :: fp\nINTEGER(C_INT) :: j\n\nCALL C_F_PROCPOINTER (cp, fp)\nj = 1\nCALL fp(j)\n...\n```"
    },
    {
      "type": "markdown",
      "data": ""
    }
  ]
}